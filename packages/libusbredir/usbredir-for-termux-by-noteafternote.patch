diff --git a/tools/usbredirect.c b/tools/usbredirect.c
index ff910ab..3cc36aa 100644
--- a/tools/usbredirect.c
+++ b/tools/usbredirect.c
@@ -1,3 +1,76 @@
+#define FOR_TERMUX 1
+
+#ifdef THIS_IS_A_COMMENT
+
+//
+// Install on termux: ninja, libusb
+// Download source code zip file from https://gitlab.freedesktop.org/spice/usbredir
+// Install on termux: https://github.com/mesonbuild/meson
+// https://mesonbuild.com/Getting-meson.html
+//
+
+// "USB redirection over the network": https://web.archive.org/web/20160114122824/www.linux-kvm.com/content/usb-redirection-over-network
+
+// "Bug 1085318 - Can't redirect tcp type USB device ": https://bugzilla.redhat.com/show_bug.cgi?id=1085318
+
+// "usbredirect doesn't know how to handle multiple identical USB devices": https://gitlab.freedesktop.org/spice/usbredir/-/issues/29
+
+// "RFE: add a usbredirclient, to use with a qemu socket chardev in server mode": https://gitlab.freedesktop.org/spice/usbredir/-/issues/1
+//    https://bugzilla.redhat.com/show_bug.cgi?id=844657
+//    https://web.archive.org/web/20160429170306/bugs.freedesktop.org/show_bug.cgi?id=72766
+
+// "Add a tcp client & server standalone binary": https://gitlab.freedesktop.org/spice/usbredir/-/merge_requests/2
+
+
+//
+// "[Spice-devel] spice-gtk usb-redirection": https://lists.freedesktop.org/archives/spice-devel/2012-July/thread.html
+//    "[Spice-devel] spice-gtk usb-redirection": https://lists.freedesktop.org/archives/spice-devel/2012-August/thread.html
+// https://hansdegoede.livejournal.com/tag/spice
+// Source code for remote-viewer (SPICE): https://gitlab.com/virt-viewer
+//
+
+#endif
+
+#ifdef THIS_IS_A_COMMENT
+
+// From https://wiki.termux.com/wiki/Termux-usb
+// and 
+// https://gist.githubusercontent.com/bndeff/8c391bc3fd8d9f1dbd133ac6ead7f45e/raw/6d7174a129301eeb670fe808cd9d25ec261f7f9e/usbtest.c
+
+
+#include <stdio.h>
+#include <assert.h>
+#include <libusb-1.0/libusb.h>
+
+int main(int argc, char **argv) {
+    libusb_context *context;
+    libusb_device_handle *handle;
+    libusb_device *device;
+    struct libusb_device_descriptor desc;
+    unsigned char buffer[256];
+    int fd;
+    assert((argc > 1) && (sscanf(argv[1], "%d", &fd) == 1));
+    libusb_set_option(NULL, LIBUSB_OPTION_WEAK_AUTHORITY);
+    assert(!libusb_init(&context));
+    assert(!libusb_wrap_sys_device(context, (intptr_t) fd, &handle));
+    device = libusb_get_device(handle);
+    assert(!libusb_get_device_descriptor(device, &desc));
+    printf("Vendor ID: %04x\n", desc.idVendor);
+    printf("Product ID: %04x\n", desc.idProduct);
+    assert(libusb_get_string_descriptor_ascii(handle, desc.iManufacturer, buffer, 256) >= 0);
+    printf("Manufacturer: %s\n", buffer);
+    assert(libusb_get_string_descriptor_ascii(handle, desc.iProduct, buffer, 256) >= 0);
+    printf("Product: %s\n", buffer);
+    if (libusb_get_string_descriptor_ascii(handle, desc.iSerialNumber, buffer, 256) >= 0)
+        printf("Serial No: %s\n", buffer);
+    libusb_exit(context);
+}
+#endif
+
+#ifdef FOR_TERMUX
+#include <assert.h>
+#endif
+
 #include "config.h"
 #include <stdio.h>
 #include <stdbool.h>
@@ -22,13 +95,19 @@
 #include <gio/gwin32outputstream.h>
 #endif
 
-struct redirect {
+typedef struct redirect {
     struct {
+        /* vendor:product */
         int vendor;
         int product;
+        /* bus-device */
+        int bus;
+        int device_number;
     } device;
+    bool by_bus;
     bool is_client;
     bool keepalive;
+    bool watch_inout;
     char *addr;
     int port;
     int verbosity;
@@ -38,51 +117,38 @@ struct redirect {
     GThread *event_thread;
     int event_thread_run;
     int watch_server_id;
+    GIOChannel *io_channel;
 
     GMainLoop *main_loop;
-};
+} redirect;
+
+static void create_watch(redirect *self);
 
 static bool
-parse_opt_device(const char *device, int *vendor, int *product)
+parse_opt_device(redirect *self, const char *device)
 {
     if (!device) {
         g_warning("No device to redirect. For testing only\n");
         return true;
     }
 
+
+#ifdef FOR_TERMUX
+    if (g_strrstr(device, "/") != NULL) {
+        return true;
+    }
+#endif
+
     if (g_strrstr(device, "-") != NULL) {
-        /* Get vendor and product by bus and address number */
+        self->by_bus = true;
         char **usbid = g_strsplit(device, "-", 2);
         if (usbid == NULL || usbid[0] == NULL || usbid[1] == NULL || usbid[2] != NULL) {
             g_strfreev(usbid);
             return false;
         }
-        gint64 bus = g_ascii_strtoll(usbid[0], NULL, 10);
-        gint64 addr = g_ascii_strtoll(usbid[1], NULL, 10);
+        self->device.bus = g_ascii_strtoll(usbid[0], NULL, 10);
+        self->device.device_number = g_ascii_strtoll(usbid[1], NULL, 10);
         g_strfreev(usbid);
-
-        libusb_device **list = NULL;
-        ssize_t i, n;
-
-        n = libusb_get_device_list(NULL, &list);
-        for (i = 0; i < n; i++) {
-            if (libusb_get_bus_number(list[i]) == bus &&
-                    libusb_get_device_address(list[i]) == addr) {
-                break;
-            }
-        }
-
-        if (i == n) {
-            libusb_free_device_list(list, true);
-            return false;
-        }
-
-        struct libusb_device_descriptor desc;
-        libusb_get_device_descriptor(list[i], &desc);
-        *vendor = desc.idVendor;
-        *product = desc.idProduct;
-
-        libusb_free_device_list(list, true);
         return true;
     }
 
@@ -92,12 +158,14 @@ parse_opt_device(const char *device, int *vendor, int *product)
         return false;
     }
 
-    *vendor = g_ascii_strtoll(usbid[0], NULL, 16);
-    *product = g_ascii_strtoll(usbid[1], NULL, 16);
+    self->device.vendor = g_ascii_strtoll(usbid[0], NULL, 16);
+    self->device.product = g_ascii_strtoll(usbid[1], NULL, 16);
     g_strfreev(usbid);
 
-    if (*vendor <= 0 || *vendor > 0xffff || *product < 0 || *product > 0xffff) {
-        g_printerr("Bad vendor:product values %04x:%04x", *vendor, *product);
+    if (self->device.vendor <= 0 || self->device.vendor > 0xffff ||
+        self->device.product < 0 || self->device.product > 0xffff) {
+        g_printerr("Bad vendor:product values %04x:%04x",
+                   self->device.vendor, self->device.product);
         return false;
     }
 
@@ -125,18 +193,24 @@ parse_opt_uri(const char *uri, char **adr, int *port)
     return true;
 }
 
-static struct redirect *
+static redirect *
 parse_opts(int *argc, char ***argv)
 {
+
+
+
+
     char *device = NULL;
     char *remoteaddr = NULL;
     char *localaddr = NULL;
     gboolean keepalive = FALSE;
     gint verbosity = 0; /* none */
-    struct redirect *self = NULL;
+    redirect *self = NULL;
+
+
 
     GOptionEntry entries[] = {
-        { "device", 0, 0, G_OPTION_ARG_STRING, &device, "Local USB device to be redirected", NULL },
+        { "device", 0, 0, G_OPTION_ARG_STRING, &device, "Local USB device to be redirected identified as either VENDOR:PRODUCT \"0123:4567\" or BUS-DEVICE \"5-2\"", NULL },
         { "to", 0, 0, G_OPTION_ARG_STRING, &remoteaddr, "Client URI to connect to", NULL },
         { "as", 0, 0, G_OPTION_ARG_STRING, &localaddr, "Server URI to be run", NULL },
         { "keepalive", 'k', 0, G_OPTION_ARG_NONE, &keepalive, "If we should set SO_KEEPALIVE flag on underlying socket", NULL },
@@ -154,6 +228,8 @@ parse_opts(int *argc, char ***argv)
         goto end;
     }
 
+
+
     /* check options */
 
     if (!remoteaddr && !localaddr) {
@@ -162,13 +238,15 @@ parse_opts(int *argc, char ***argv)
         goto end;
     }
 
-    self = g_new0(struct redirect, 1);
-    if (!parse_opt_device(device, &self->device.vendor, &self->device.product)) {
+    self = g_new0(redirect, 1);
+    self->watch_inout = true;
+    if (!parse_opt_device(self, device)) {
         g_printerr("Failed to parse device: '%s' - expected: vendor:product or busnum-devnum\n", device);
         g_clear_pointer(&self, g_free);
         goto end;
     }
 
+
     if (parse_opt_uri(remoteaddr, &self->addr, &self->port)) {
         self->is_client = true;
     } else if (!parse_opt_uri(localaddr, &self->addr, &self->port)) {
@@ -202,7 +280,7 @@ end:
 static gpointer
 thread_handle_libusb_events(gpointer user_data)
 {
-    struct redirect *self = (struct redirect *) user_data;
+    redirect *self = (redirect *) user_data;
 
     int res = 0;
     const char *desc = "";
@@ -277,10 +355,25 @@ usbredir_log_cb(void *priv, int level, const char *msg)
     g_log_structured(G_LOG_DOMAIN, glog_level, "MESSAGE", msg);
 }
 
+static void
+update_watch(redirect *self)
+{
+    const bool watch_inout = usbredirhost_has_data_to_write(self->usbredirhost) != 0;
+    if (watch_inout == self->watch_inout) {
+        return;
+    }
+    g_clear_pointer(&self->io_channel, g_io_channel_unref);
+    g_source_remove(self->watch_server_id);
+    self->watch_server_id = 0;
+    self->watch_inout = watch_inout;
+
+    create_watch(self);
+}
+
 static int
 usbredir_read_cb(void *priv, uint8_t *data, int count)
 {
-    struct redirect *self = (struct redirect *) priv;
+    redirect *self = (redirect *) priv;
     GIOStream *iostream = G_IO_STREAM(self->connection);
     GError *err = NULL;
 
@@ -308,7 +401,7 @@ usbredir_read_cb(void *priv, uint8_t *data, int count)
 static int
 usbredir_write_cb(void *priv, uint8_t *data, int count)
 {
-    struct redirect *self = (struct redirect *) priv;
+    redirect *self = (redirect *) priv;
     GIOStream *iostream = G_IO_STREAM(self->connection);
     GError *err = NULL;
 
@@ -322,6 +415,7 @@ usbredir_write_cb(void *priv, uint8_t *data, int count)
         if (g_error_matches(err, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK)) {
             /* Try again later */
             nbytes = 0;
+            update_watch(self);
         } else {
             if (err != NULL) {
                 g_warning("Failure at %s: %s", __func__, err->message);
@@ -336,7 +430,7 @@ usbredir_write_cb(void *priv, uint8_t *data, int count)
 static void
 usbredir_write_flush_cb(void *user_data)
 {
-    struct redirect *self = (struct redirect *) user_data;
+    redirect *self = (redirect *) user_data;
     if (!self || !self->usbredirhost) {
         return;
     }
@@ -387,7 +481,7 @@ usbredir_unlock_lock(void *user_data)
 static gboolean
 connection_handle_io_cb(GIOChannel *source, GIOCondition condition, gpointer user_data)
 {
-    struct redirect *self = (struct redirect *) user_data;
+    redirect *self = (redirect *) user_data;
 
     if (condition & G_IO_ERR || condition & G_IO_HUP) {
         g_warning("Connection: err=%d, hup=%d - exiting", (condition & G_IO_ERR), (condition & G_IO_HUP));
@@ -401,13 +495,18 @@ connection_handle_io_cb(GIOChannel *source, GIOCondition condition, gpointer use
             goto end;
         }
     }
-    if (condition & G_IO_OUT) {
+    // try to write data in any case, to avoid having another iteration and
+    // creation of another watch if there is space in output buffer
+    if (usbredirhost_has_data_to_write(self->usbredirhost) != 0) {
         int ret = usbredirhost_write_guest_data(self->usbredirhost);
         if (ret < 0) {
             g_critical("%s: Failed to write to guest", __func__);
             goto end;
         }
     }
+
+    // update the watch if needed
+    update_watch(self);
     return G_SOURCE_CONTINUE;
 
 end:
@@ -415,34 +514,143 @@ end:
     return G_SOURCE_REMOVE;
 }
 
+static void
+create_watch(redirect *self)
+{
+    GSocket *socket = g_socket_connection_get_socket(self->connection);
+    int socket_fd = g_socket_get_fd(socket);
+
+    g_assert_null(self->io_channel);
+    self->io_channel =
+#ifdef G_OS_UNIX
+        g_io_channel_unix_new(socket_fd);
+#else
+        g_io_channel_win32_new_socket(socket_fd);
+#endif
+
+    g_assert_cmpint(self->watch_server_id, ==, 0);
+    self->watch_server_id = g_io_add_watch(self->io_channel,
+            G_IO_IN | G_IO_HUP | G_IO_ERR | (self->watch_inout ? G_IO_OUT : 0),
+            connection_handle_io_cb,
+            self);
+}
+
 #ifdef G_OS_UNIX
 static gboolean
 signal_handler(gpointer user_data)
 {
-    struct redirect *self = (struct redirect *) user_data;
+    redirect *self = (redirect *) user_data;
     g_main_loop_quit(self->main_loop);
     return G_SOURCE_REMOVE;
 }
 #endif
 
+static bool
+can_claim_usb_device(libusb_device *dev, libusb_device_handle **handle)
+{
+    int ret = libusb_open(dev, handle);
+    if (ret != 0) {
+        g_debug("Failed to open device");
+        return false;
+    }
+
+    /* Opening is not enough. We need to check if device can be claimed
+     * for I/O operations */
+    struct libusb_config_descriptor *config = NULL;
+    ret = libusb_get_active_config_descriptor(dev, &config);
+    if (ret != 0 || config == NULL) {
+        g_debug("Failed to get active descriptor");
+        goto fail;
+    }
+
+#if LIBUSBX_API_VERSION >= 0x01000102
+    libusb_set_auto_detach_kernel_driver(*handle, 1);
+#endif
+
+    int i;
+    for (i = 0; i < config->bNumInterfaces; i++) {
+        int interface_num = config->interface[i].altsetting[0].bInterfaceNumber;
+#if LIBUSBX_API_VERSION < 0x01000102
+        ret = libusb_detach_kernel_driver(handle, interface_num);
+        if (ret != 0 && ret != LIBUSB_ERROR_NOT_FOUND
+            && ret != LIBUSB_ERROR_NOT_SUPPORTED) {
+            g_error("failed to detach driver from interface %d: %s",
+                    interface_num, libusb_error_name(ret));
+            goto fail;
+        }
+#endif
+        ret = libusb_claim_interface(*handle, interface_num);
+        if (ret != 0) {
+            g_debug("Could not claim interface");
+            goto fail;
+        }
+        ret = libusb_release_interface(*handle, interface_num);
+        if (ret != 0) {
+            g_debug("Could not release interface");
+            goto fail;
+        }
+    }
+
+    libusb_free_config_descriptor(config);
+    return true;
+
+fail:
+    libusb_free_config_descriptor(config);
+    libusb_close(*handle);
+    *handle = NULL;
+    return false;
+}
+
+static libusb_device_handle *
+open_usb_device(redirect *self)
+{
+    struct libusb_device **devs;
+    struct libusb_device_handle *dev_handle = NULL;
+    size_t i, ndevices;
+
+    ndevices = libusb_get_device_list(NULL, &devs);
+    for (i = 0; i < ndevices; i++) {
+        struct libusb_device_descriptor desc;
+        if (libusb_get_device_descriptor(devs[i], &desc) != 0) {
+            g_warning("Failed to get descriptor");
+            continue;
+        }
+
+        if (self->by_bus &&
+            (self->device.bus != libusb_get_bus_number(devs[i]) ||
+             self->device.device_number != libusb_get_device_address(devs[i]))) {
+             continue;
+        }
+
+        if (!self->by_bus &&
+            (self->device.vendor != desc.idVendor ||
+             self->device.product != desc.idProduct)) {
+             continue;
+        }
+
+        if (can_claim_usb_device(devs[i], &dev_handle)) {
+            break;
+        }
+    }
+
+    libusb_free_device_list(devs, 1);
+    return dev_handle;
+}
+
+
 static gboolean
 connection_incoming_cb(GSocketService    *service,
                        GSocketConnection *client_connection,
                        GObject           *source_object,
                        gpointer           user_data)
 {
-    struct redirect *self = (struct redirect *) user_data;
+    redirect *self = (redirect *) user_data;
     self->connection = g_object_ref(client_connection);
 
     /* Add a GSource watch to handle polling for us and handle IO in the callback */
     GSocket *connection_socket = g_socket_connection_get_socket(self->connection);
     g_socket_set_keepalive(connection_socket, self->keepalive);
-    int socket_fd = g_socket_get_fd(connection_socket);
-    GIOChannel *io_channel = g_io_channel_unix_new(socket_fd);
-    self->watch_server_id = g_io_add_watch(io_channel,
-            G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR,
-            connection_handle_io_cb,
-            self);
+    create_watch(self);
     return G_SOURCE_REMOVE;
 }
 
@@ -450,18 +658,42 @@ int
 main(int argc, char *argv[])
 {
     GError *err = NULL;
+    
+
 
+#ifdef THIS_IS_A_COMMENT
     if (libusb_init(NULL)) {
         g_warning("Could not init libusb\n");
         goto err_init;
     }
+#endif
+
+
+
+
+#ifdef FOR_TERMUX
+printf("\n\nIN-MAIN-BEFORE-parse_opts argc = %d\n\n", argc) ;
+printf("\n\nIN-MAIN-BEFORE-parse_opts argv[0] = %s\n\n", argv[0]) ;
+printf("\n\nIN-MAIN-BEFORE-parse_opts argv[1] = %s\n\n", argv[1]) ;
+printf("\n\nIN-MAIN-BEFORE-parse_opts argv[2] = %s\n\n", argv[2]) ;
+printf("\n\nIN-MAIN-BEFORE-parse_opts argv[3] = %s\n\n", argv[3]) ;
+printf("\n\nIN-MAIN-BEFORE-parse_opts argv[4] = %s\n\n", argv[4]) ;
+printf("\n\nIN-MAIN-BEFORE-parse_opts argv[5] = %s\n\n", argv[5]) ;
+// printf("\n\nIN-MAIN-BEFORE-parse_opts argv[6] = %s\n\n", argv[6]) ;
+// printf("\n\nIN-MAIN-BEFORE-parse_opts argv[7] = %s\n\n", argv[7]) ;
+#endif
+
+
+    redirect *self = parse_opts(&argc, &argv);
 
-    struct redirect *self = parse_opts(&argc, &argv);
     if (!self) {
         /* specific issues logged in parse_opts() */
         return 1;
     }
 
+
+
+
 #if LIBUSBX_API_VERSION >= 0x01000107
     /* This was introduced in 1.0.23 */
     libusb_set_log_cb(NULL, debug_libusb_cb, LIBUSB_LOG_CB_GLOBAL);
@@ -470,7 +702,9 @@ main(int argc, char *argv[])
 #ifdef G_OS_WIN32
     /* WinUSB is the default by backwards compatibility so this is needed to
      * switch to USBDk backend. */
+#   if LIBUSBX_API_VERSION >= 0x01000106
     libusb_set_option(NULL, LIBUSB_OPTION_USE_USBDK); 
+#   endif
 #endif
 
 #ifdef G_OS_UNIX
@@ -479,15 +713,57 @@ main(int argc, char *argv[])
     g_unix_signal_add(SIGTERM, signal_handler, self);
 #endif
 
-    /* This is binary is not meant to support plugins so it is safe to pass
-     * NULL as libusb_context here and all subsequent calls */
-    libusb_device_handle *device_handle = libusb_open_device_with_vid_pid(NULL,
-            self->device.vendor,
-            self->device.product);
+
+
+
+
+#ifdef THIS_IS_A_COMMENT
+    libusb_device_handle *device_handle = open_usb_device(self);
     if (!device_handle) {
         g_printerr("Failed to open device!\n");
         goto err_init;
     }
+#endif
+
+#ifdef FOR_TERMUX
+    libusb_context *context;
+    libusb_device_handle *device_handle;
+    libusb_device *termux_device;
+    struct libusb_device_descriptor desc;
+    unsigned char buffer[256];
+    int fd;
+
+#ifdef FOR_TERMUX
+printf("\n\nIN-MAIN-BEFORE sscanf argc = %d\n\n", argc) ;
+printf("\n\nIN-MAIN-BEFORE sscanf argv[0] = %s\n\n", argv[0]) ;
+printf("\n\nIN-MAIN-BEFORE sscanf argv[1] = %s\n\n", argv[1]) ;
+printf("\n\nIN-MAIN-BEFORE sscanf argv[2] = %s\n\n", argv[2]) ;
+printf("\n\nIN-MAIN-BEFORE sscanf argv[3] = %s\n\n", argv[3]) ;
+printf("\n\nIN-MAIN-BEFORE sscanf argv[4] = %s\n\n", argv[4]) ;
+printf("\n\nIN-MAIN-BEFORE sscanf argv[5] = %s\n\n", argv[5]) ;
+// printf("\n\nIN-MAIN-BEFORE sscanf argv[6] = %s\n\n", argv[6]) ;
+// printf("\n\nIN-MAIN-BEFORE sscanf argv[7] = %s\n\n", argv[7]) ;
+#endif
+
+    assert(sscanf(argv[1], "%d", &fd) == 1);
+    libusb_set_option(NULL, LIBUSB_OPTION_WEAK_AUTHORITY);
+    assert(!libusb_init(&context));
+    assert(!libusb_wrap_sys_device(context, (intptr_t) fd, &device_handle));
+    termux_device = libusb_get_device(device_handle);
+    assert(!libusb_get_device_descriptor(termux_device, &desc));
+    printf("Vendor ID: %04x\n", desc.idVendor);
+    printf("Product ID: %04x\n", desc.idProduct);
+    assert(libusb_get_string_descriptor_ascii(device_handle, desc.iManufacturer, buffer, 256) >= 0);
+    printf("Manufacturer: %s\n", buffer);
+    assert(libusb_get_string_descriptor_ascii(device_handle, desc.iProduct, buffer, 256) >= 0);
+    printf("Product: %s\n", buffer);
+    if (libusb_get_string_descriptor_ascii(device_handle, desc.iSerialNumber, buffer, 256) >= 0)
+        printf("Serial No: %s\n", buffer);
+
+#endif
+
+
+
 
     /* As per doc below, we are not using hotplug so we must first call
      * libusb_open() and then we can start the event thread.
@@ -529,11 +805,15 @@ main(int argc, char *argv[])
     /* Only allow libusb logging if log verbosity is uredirparser_debug_data
      * (or higher), otherwise we disable it here while keeping usbredir's logs enable. */
     if  (self->verbosity < usbredirparser_debug_data)  {
+#if LIBUSBX_API_VERSION >= 0x01000106
         int ret = libusb_set_option(NULL, LIBUSB_OPTION_LOG_LEVEL, LIBUSB_LOG_LEVEL_NONE);
         if (ret != LIBUSB_SUCCESS) {
             g_warning("error disabling libusb log level: %s", libusb_error_name(ret));
             goto end;
         }
+#else
+        libusb_set_debug(NULL, LIBUSB_LOG_LEVEL_NONE);
+#endif
     }
 
     if (self->is_client) {
@@ -552,17 +832,7 @@ main(int argc, char *argv[])
 
         GSocket *connection_socket = g_socket_connection_get_socket(self->connection);
         g_socket_set_keepalive(connection_socket, self->keepalive);
-        int socket_fd = g_socket_get_fd(connection_socket);
-        GIOChannel *io_channel =
-#ifdef G_OS_UNIX
-            g_io_channel_unix_new(socket_fd);
-#else
-            g_io_channel_win32_new_socket(socket_fd);
-#endif
-        self->watch_server_id = g_io_add_watch(io_channel,
-                G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR,
-                connection_handle_io_cb,
-                self);
+        create_watch(self);
     } else {
         GSocketService *socket_service;
 
@@ -595,6 +865,7 @@ main(int argc, char *argv[])
 
     self->main_loop = g_main_loop_new(NULL, FALSE);
     g_main_loop_run(self->main_loop);
+    g_clear_pointer(&self->main_loop, g_main_loop_unref);
 
     g_atomic_int_set(&self->event_thread_run, FALSE);
     if (self->event_thread) {
@@ -618,3 +889,4 @@ err_init:
 
     return 0;
 }
+
